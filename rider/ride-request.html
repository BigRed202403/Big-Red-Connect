/**
 * ============================================================
 * üöó BIG RED CONNECT ‚Äî BOOKINGS WORKER (LIVE)
 * Version: 2025-12-30b (force rider cancel/decline ‚Üí driver/admin push)
 * ============================================================
 */

export default {
  async fetch(request, env, ctx) {
    const url = new URL(request.url);
    const { pathname, searchParams } = url;
    const method = request.method.toUpperCase();

    // ---------------- CORS ----------------
    if (method === "OPTIONS") {
      return new Response(null, { status: 204, headers: corsHeaders() });
    }

    // ---------------- Health ----------------
    if (pathname === "/" && method === "GET") {
      return json({ ok: true, service: "bigred-bookings" });
    }

    // ========================================================
    // POST /api/bookings  ‚Üí create new booking (rider)
    // ========================================================
    if (pathname === "/api/bookings" && method === "POST") {
      let body;
      try { body = await request.json(); }
      catch { return json({ error: "Invalid JSON" }, 400); }

      const nowIso = new Date().toISOString();
      const id = "BR" + Date.now().toString(36) + "-" + crypto.randomUUID().slice(0, 8);

      const pickup = body.pickup || {};
      const dropoff = body.dropoff || {};
      const stops = Array.isArray(body.stops) ? body.stops : [];
      const rider = body.rider || {};
      const pricing = body.pricing || {};
      const metrics = body.metrics || {};
      const metadata = body.metadata || {};

      if (!pickup.address || !dropoff.address) {
        return json({ error: "Missing pickup or dropoff address" }, 400);
      }

      const booking = {
        id,
        type: body.type === "RESERVATION" ? "RESERVATION" : "INSTANT",
        status: "REQUESTED",
        createdAt: nowIso,
        updatedAt: nowIso,

        pickup,
        dropoff,
        stops,

        rider: {
          riderId: rider.riderId || null,
          name: rider.name || "",
          phone: rider.phone || "",
          partySize: rider.partySize ?? 1,
          luggagePieces: rider.luggagePieces ?? 0
        },

        pricing: {
          estimate: Number(pricing.estimate ?? 0),
          travelFee: Number(pricing.travelFee ?? 0),
          ratePlan: pricing.ratePlan || "STANDARD"
        },

        metrics: {
          miles: Number(metrics.miles ?? 0),
          minutes: Number(metrics.minutes ?? 0)
        },

        scheduledFor: body.scheduledFor || null,
        source: body.source || "RIDE_REQUEST",
        vehicle: body.vehicle || null,

        metadata: {
          notifyDriver: !!metadata.notifyDriver,
          routeUrl: metadata.routeUrl || null,
          ...metadata
        }
      };

      await env.BOOKINGS_STORE.put(`booking:${id}`, JSON.stringify(booking));

      // üîî Notify driver/admin of new request (rider ‚Üí driver/admin)
      if (env.PUSH_RIDER_TO_DRIVER_URL) {
        ctx.waitUntil(notifyDriverOfNewBooking(env, booking).catch(() => {}));
      }

      return json(booking, 201);
    }

    // ========================================================
    // GET /api/driver/bookings
    // ========================================================
    if (pathname === "/api/driver/bookings" && method === "GET") {
      const scope = (searchParams.get("scope") || "active").toLowerCase();
      const list = await env.BOOKINGS_STORE.list({ prefix: "booking:" });
      const out = [];

      for (const k of list.keys) {
        const raw = await env.BOOKINGS_STORE.get(k.name);
        if (!raw) continue;
        try {
          const b = JSON.parse(raw);
          if (filterByScope(b, scope)) out.push(b);
        } catch {}
      }

      out.sort((a, b) => (b.createdAt || "").localeCompare(a.createdAt || ""));
      return json(out);
    }

    // ========================================================
    // POST /api/rider/claim-rides
    // ========================================================
    if (pathname === "/api/rider/claim-rides" && method === "POST") {
      let body;
      try { body = await request.json(); }
      catch { return json({ error: "Invalid JSON" }, 400); }

      const riderId = String(body.riderId || "").trim();
      const phoneIn = String(body.phone || "").replace(/\D/g, "");

      if (!riderId || phoneIn.length < 10) {
        return json({ error: "Missing riderId or phone" }, 400);
      }

      const list = await env.BOOKINGS_STORE.list({ prefix: "booking:" });
      let updated = 0;
      const rideIds = [];

      for (const k of list.keys) {
        const raw = await env.BOOKINGS_STORE.get(k.name);
        if (!raw) continue;

        let b;
        try { b = JSON.parse(raw); } catch { continue; }

        const status = String(b.status || "").toUpperCase();
        const isOpen = !["COMPLETED", "CANCELLED", "DECLINED"].includes(status);
        if (!isOpen) continue;

        const bPhone = String(b?.rider?.phone || "").replace(/\D/g, "");
        const hasRiderId = !!(b?.rider?.riderId);

        if (bPhone && bPhone === phoneIn && !hasRiderId) {
          b.rider = b.rider || {};
          b.rider.riderId = riderId;
          b.updatedAt = new Date().toISOString();
          await env.BOOKINGS_STORE.put(k.name, JSON.stringify(b));
          updated++;
          rideIds.push(b.id);
        }
      }

      return json({ ok: true, updated, rideIds });
    }

    // ========================================================
    // PUT /api/driver/bookings/:id
    // ========================================================
    if (pathname.startsWith("/api/driver/bookings/") && method === "PUT") {
      const id = pathname.split("/").pop();
      const key = `booking:${id}`;
      const raw = await env.BOOKINGS_STORE.get(key);
      if (!raw) return json({ error: "Not found" }, 404);

      let booking;
      try { booking = JSON.parse(raw); }
      catch { return json({ error: "Corrupt record" }, 500); }

      let body;
      try { body = await request.json(); }
      catch { return json({ error: "Invalid JSON" }, 400); }

      const prevStatus = String(booking.status || "").toUpperCase();
      const requestedStatus = body.status ? String(body.status).toUpperCase() : null;

      // Apply updates
      if (requestedStatus) booking.status = requestedStatus;

      if (body.vehicle) {
        booking.vehicle = {
          code: body.vehicle.code || null,
          label: body.vehicle.label || null,
          image: body.vehicle.image || null
        };
      }

      if (body.metadata && typeof body.metadata === "object") {
        booking.metadata = { ...(booking.metadata || {}), ...body.metadata };
      }

      booking.updatedAt = new Date().toISOString();
      await env.BOOKINGS_STORE.put(key, JSON.stringify(booking));

      const newStatus = String(booking.status || "").toUpperCase();

      // ======================================================
      // üîî IMPORTANT: Rider ‚Üí Driver/Admin cancel/decline push
      // Fire based on the REQUESTED status in the PUT body
      // (so it can't be missed due to transition quirks)
      // ======================================================
      if (
        env.PUSH_RIDER_TO_DRIVER_URL &&
        (requestedStatus === "CANCELLED" || requestedStatus === "DECLINED")
      ) {
        // Use waitUntil but also DO NOT swallow silently; include safe timeout-ish behavior by awaiting
        try {
          await notifyDriverOfRiderClosed(env, booking, requestedStatus);
        } catch (e) {
          // non-blocking (but you can view logs in CF)
          console.log("cancel/decline push failed:", String(e));
        }
      } else {
        // Backup: transition-based (older path)
        if (
          env.PUSH_RIDER_TO_DRIVER_URL &&
          newStatus !== prevStatus &&
          (newStatus === "CANCELLED" || newStatus === "DECLINED")
        ) {
          ctx.waitUntil(notifyDriverOfRiderClosed(env, booking, newStatus).catch(() => {}));
        }
      }

      // üîî Driver ‚Üí Rider status push (only if riderId exists)
      if (
        env.PUSH_DRIVER_TO_RIDER_URL &&
        booking.rider?.riderId &&
        newStatus !== prevStatus
      ) {
        const msg = buildRiderStatusMessage(newStatus);
        if (msg) {
          ctx.waitUntil(
            notifyRiderOfStatus(env, booking.rider.riderId, booking.id, msg.title, msg.body)
              .catch(() => {})
          );
        }
      }

      return json({ ok: true, booking });
    }

    // ========================================================
    // GET /api/bookings/:id
    // ========================================================
    if (pathname.startsWith("/api/bookings/") && method === "GET") {
      const id = pathname.split("/").pop();
      const raw = await env.BOOKINGS_STORE.get(`booking:${id}`);
      if (!raw) return json({ error: "Not found" }, 404);
      return json(JSON.parse(raw));
    }

    return json({ error: "Not found" }, 404);
  }
};

/* ============================
   Helpers
   ============================ */

function corsHeaders() {
  return {
    "Access-Control-Allow-Origin": "*",
    "Access-Control-Allow-Methods": "GET,POST,PUT,OPTIONS",
    "Access-Control-Allow-Headers": "Content-Type, X-Admin-Secret"
  };
}

function json(obj, status = 200) {
  return new Response(JSON.stringify(obj, null, 2), {
    status,
    headers: { ...corsHeaders(), "Content-Type": "application/json" }
  });
}

function filterByScope(b, scope) {
  const s = (b.status || "").toUpperCase();
  const active = ["REQUESTED", "ACCEPTED", "ENROUTE", "ARRIVED", "PICKED_UP"];
  if (scope === "active") return active.includes(s);
  return true;
}

function buildRiderStatusMessage(status) {
  switch (String(status || "").toUpperCase()) {
    case "ACCEPTED":   return { title: "Ride Accepted", body: "Your ride has been accepted." };
    case "ENROUTE":    return { title: "Driver En Route", body: "Big Red is on the way." };
    case "ARRIVED":    return { title: "Driver Arrived", body: "Big Red has arrived." };
    case "PICKED_UP":  return { title: "Ride Started", body: "You're on the move!" };
    case "COMPLETED":  return { title: "Ride Completed", body: "Thanks for riding Big Red Connect!" };
    case "CANCELLED":  return { title: "Ride Cancelled", body: "Your ride was cancelled." };
    case "DECLINED":   return { title: "Ride Declined", body: "This request was declined." };
    default: return null;
  }
}

async function notifyDriverOfNewBooking(env, booking) {
  await fetch(env.PUSH_RIDER_TO_DRIVER_URL, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({
      title: "üöó New Ride Request",
      message: `${booking.pickup?.address || "?"} ‚Üí ${booking.dropoff?.address || "?"}`,
      kind: "REQUESTED",
      rideId: booking.id,
      riderPhone: booking?.rider?.phone || null,
      url: "https://bigredconnectokc.com/admin-driver.html"
    })
  });
}

async function notifyDriverOfRiderClosed(env, booking, closedStatus) {
  const st = String(closedStatus || "").toUpperCase();
  const title = st === "CANCELLED" ? "‚ùå Ride Cancelled" : "üö´ Ride Declined";
  const riderName = booking?.rider?.name || "Rider";

  await fetch(env.PUSH_RIDER_TO_DRIVER_URL, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({
      title,
      message: `${riderName}: ${booking.pickup?.address || "?"} ‚Üí ${booking.dropoff?.address || "?"}`,
      kind: st,
      rideId: booking.id,
      riderPhone: booking?.rider?.phone || null,
      url: "https://bigredconnectokc.com/admin-driver.html"
    })
  });
}

async function notifyRiderOfStatus(env, riderId, rideId, title, message) {
  await fetch(env.PUSH_DRIVER_TO_RIDER_URL, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({
      type: "rider",
      riderId,
      rideId,
      title,
      message
    })
  });
}